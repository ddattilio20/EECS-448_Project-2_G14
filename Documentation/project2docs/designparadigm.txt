We believe the Project 1 team used the object-oriented design paradigm. They separated their game into three files, one part for the main operation, one part for the executive/game logic aspect, and one part for the game boards. Each file contains a Python class with relevant methods and variables. The files interact with each other to execute the game. The main file instantiates and calls the executive class, and the executive class calls methods from the gameBoard class to check different conditions such as placing ships and taking shots. Each class focuses on its relevant data, like the executive class focuses on whose turn it is, and the gameBoard class focuses on the players' boards. Then the classes have the relevant methods for checking and modifying the data they contain. For example, the gameBoard class contains the methods placeShip, shipSunk, and printPlayerView, to name a few. The placeShip method attempts to place a ship with the rotation and location that is passed in, and then returns whether the placement failed or not. The shipSunk method checks the board to see if any pieces of a specific ship have not been sunk yet. The printPlayerView method goes through the board array and converts the information at each index into an appropriate symbol for visualizing the board and prints it. All of these methods interact exclusively with the board array itself, fitting into the object-oriented paradigm where each object and its methods primarily interact with its own data that it is representing. On the other hand, the executive class and its methods like setUp and takeTurn really only handle the user interaction aspect and the main game state. All of the methods related to placement or shooting actually call methods in the gameBoard class to handle directly interacting with the board data.